package messiah;

import messiah.search.generic.SearchResult;
import messiah.search.SearchAlgoEnum;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.ItemEvent;
import java.io.File;
import java.text.DecimalFormat;
import java.util.*;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import messiah.database.Database;
import messiah.storage.generic.DbAccess;
import javax.swing.JTree;
import messiah.parse.RandomIntervalGenerator;
import messiah.parse.StaticIntervalGenerator;
import messiah.parse.ParsedTimetampIntervalGenerator;
import usu.algebra.KeywordSearchExpression;

/**
 * The UI frame
 *
 * @author truongbaquan and Curtis Dyreson
 */
public class TempUserInterface extends javax.swing.JFrame {

    private Main controller = new Main();

    /**
     * Creates new form UserInterface
     */
    public TempUserInterface() {
        initComponents();
        //this.algoComboBox.setModel(new DefaultComboBoxModel(SearchAlgoEnum.values()));
        this.getRootPane().setDefaultButton(searchButton);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        indexButtonGroup = new javax.swing.ButtonGroup();
        algoButtonGroup = new javax.swing.ButtonGroup();
        inputPanel = new javax.swing.JPanel();
        searchButton = new javax.swing.JButton();
        searchBox = new javax.swing.JTextField();
        resultPane = new javax.swing.JScrollPane();
        resultArea = new javax.swing.JTextArea();
        searchTime = new javax.swing.JLabel();
        structuredScrollPane = new javax.swing.JScrollPane();
        chooseDataPane = new javax.swing.JTabbedPane();
        parseDataPane = new javax.swing.JPanel();
        datasetPanel = new javax.swing.JPanel();
        configurePane = new javax.swing.JTabbedPane();
        fixedIntervalPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        staticTimestampSizeField = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        randomIntervalPanel = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        timelineSize = new javax.swing.JTextField();
        maxIntervalSize = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        parseRepresentationPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        browseButton = new javax.swing.JButton();
        jPanel6 = new javax.swing.JPanel();
        loadDB_Button = new javax.swing.JButton();
        xmlFile_jTextField = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Temporal JSON Keyword Search (TJKS)");
        setName("mainFrame"); // NOI18N

        inputPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Keyword Search Query"));
        inputPanel.setToolTipText("Fill in a keyword search query");

        searchButton.setText("Search");
        searchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                searchButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout inputPanelLayout = new javax.swing.GroupLayout(inputPanel);
        inputPanel.setLayout(inputPanelLayout);
        inputPanelLayout.setHorizontalGroup(
            inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputPanelLayout.createSequentialGroup()
                .addGroup(inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addGroup(inputPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(searchBox))
                    .addComponent(searchButton))
                .addContainerGap())
        );
        inputPanelLayout.setVerticalGroup(
            inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputPanelLayout.createSequentialGroup()
                .addComponent(searchBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(11, 11, 11)
                .addComponent(searchButton))
        );

        resultPane.setBorder(null);
        resultPane.setViewportBorder(javax.swing.BorderFactory.createTitledBorder("Results"));

        resultArea.setEditable(false);
        resultArea.setBackground(new java.awt.Color(240, 240, 240));
        resultArea.setColumns(20);
        resultArea.setRows(10);
        resultArea.setAutoscrolls(false);
        resultArea.setBorder(null);
        resultPane.setViewportView(resultArea);
        resultArea.getAccessibleContext().setAccessibleParent(resultArea);

        structuredScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Structural Summary"));

        chooseDataPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose Data"));
        chooseDataPane.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                chooseDataPaneStateChanged(evt);
            }
        });

        datasetPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Configure Timestamp Assignment"));
        datasetPanel.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                datasetPanelFocusGained(evt);
            }
        });
        datasetPanel.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                datasetPanelComponentShown(evt);
            }
        });

        jLabel1.setText("The same time is used throughout.");

        staticTimestampSizeField.setText("100");

        jLabel4.setText("Size of timestamp");

        javax.swing.GroupLayout fixedIntervalPanelLayout = new javax.swing.GroupLayout(fixedIntervalPanel);
        fixedIntervalPanel.setLayout(fixedIntervalPanelLayout);
        fixedIntervalPanelLayout.setHorizontalGroup(
            fixedIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(fixedIntervalPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(fixedIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 321, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(fixedIntervalPanelLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(staticTimestampSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(157, Short.MAX_VALUE))
        );
        fixedIntervalPanelLayout.setVerticalGroup(
            fixedIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(fixedIntervalPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(fixedIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(staticTimestampSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addContainerGap(34, Short.MAX_VALUE))
        );

        configurePane.addTab("Fixed Interval", fixedIntervalPanel);

        jLabel3.setText("Timestamps are randomly generated.");

        timelineSize.setText("100");

        maxIntervalSize.setText("100");

        jLabel5.setText("Size of timeline");

        jLabel6.setText("Maximum interval size");

        javax.swing.GroupLayout randomIntervalPanelLayout = new javax.swing.GroupLayout(randomIntervalPanel);
        randomIntervalPanel.setLayout(randomIntervalPanelLayout);
        randomIntervalPanelLayout.setHorizontalGroup(
            randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(randomIntervalPanelLayout.createSequentialGroup()
                .addGroup(randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(randomIntervalPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 321, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(randomIntervalPanelLayout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addGroup(randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(maxIntervalSize, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(timelineSize, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(157, Short.MAX_VALUE))
        );
        randomIntervalPanelLayout.setVerticalGroup(
            randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(randomIntervalPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(timelineSize, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(randomIntervalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(maxIntervalSize, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        configurePane.addTab("Random Interval", randomIntervalPanel);

        jLabel2.setText("Timestamps are in the JSON file to parse.");

        javax.swing.GroupLayout parseRepresentationPanelLayout = new javax.swing.GroupLayout(parseRepresentationPanel);
        parseRepresentationPanel.setLayout(parseRepresentationPanelLayout);
        parseRepresentationPanelLayout.setHorizontalGroup(
            parseRepresentationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(parseRepresentationPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 321, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(157, Short.MAX_VALUE))
        );
        parseRepresentationPanelLayout.setVerticalGroup(
            parseRepresentationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(parseRepresentationPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2)
                .addContainerGap(62, Short.MAX_VALUE))
        );

        configurePane.addTab("Parse Representation", parseRepresentationPanel);

        javax.swing.GroupLayout datasetPanelLayout = new javax.swing.GroupLayout(datasetPanel);
        datasetPanel.setLayout(datasetPanelLayout);
        datasetPanelLayout.setHorizontalGroup(
            datasetPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(configurePane)
        );
        datasetPanelLayout.setVerticalGroup(
            datasetPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(configurePane, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        configurePane.getAccessibleContext().setAccessibleDescription("");

        browseButton.setText("Browse...");
        browseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                browseButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout parseDataPaneLayout = new javax.swing.GroupLayout(parseDataPane);
        parseDataPane.setLayout(parseDataPaneLayout);
        parseDataPaneLayout.setHorizontalGroup(
            parseDataPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(parseDataPaneLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(datasetPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(browseButton)
                .addContainerGap(296, Short.MAX_VALUE))
        );
        parseDataPaneLayout.setVerticalGroup(
            parseDataPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, parseDataPaneLayout.createSequentialGroup()
                .addComponent(datasetPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(22, 22, 22))
            .addGroup(parseDataPaneLayout.createSequentialGroup()
                .addGap(60, 60, 60)
                .addComponent(browseButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        chooseDataPane.addTab("Parse New Dataset", parseDataPane);

        jPanel6.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jPanel6FocusGained(evt);
            }
        });

        loadDB_Button.setText("Load DB");
        loadDB_Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadDB_ButtonActionPerformed(evt);
            }
        });

        xmlFile_jTextField.setEditable(false);
        xmlFile_jTextField.setText("Please select a JSON file");
        xmlFile_jTextField.setToolTipText("Use this box to browse to your JSON");
        xmlFile_jTextField.setBorder(null);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(xmlFile_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(loadDB_Button)
                .addContainerGap(670, Short.MAX_VALUE))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(loadDB_Button)
                    .addComponent(xmlFile_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(99, Short.MAX_VALUE))
        );

        chooseDataPane.addTab("Load Existing Dataset", jPanel6);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(searchTime, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(structuredScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 205, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(chooseDataPane, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(inputPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(resultPane))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(chooseDataPane, javax.swing.GroupLayout.PREFERRED_SIZE, 201, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(inputPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(resultPane, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE))
                    .addComponent(structuredScrollPane))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(searchTime, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        inputPanel.getAccessibleContext().setAccessibleName("Search Query");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     *
     * @param evt triggered on clicking the search button
     */
    private void searchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_searchButtonActionPerformed
        DecimalFormat searchtime = new DecimalFormat("#0.000 msec");
        try {
            if (!this.controller.isInitialized()) {
                String msg = "Database not selected.\nPlease load a Database before searching.";
                JOptionPane.showMessageDialog(this, msg, "Warning", JOptionPane.WARNING_MESSAGE);
                return;
            }

            String searchText = searchBox.getText();
            SearchAlgoEnum searchAlgo;
            if (!isAlgoManualSelected()) {
                searchAlgo = this.controller.selectAlgo(searchText);
                //this.algoComboBox.setSelectedItem(searchAlgo);
            } else {
                //searchAlgo = (SearchAlgoEnum) this.algoComboBox.getSelectedItem();
            }
            KeywordSearchExpression exp = this.controller.compileFromString(searchText);
            SearchResult result = this.controller.search(this.isIndexedUsed(),exp,true);

            //generate results and make a JTree
            JTree resultTree = result.getResultTree();
            //resultTree.setCellRenderer(new PathTreeCellRenderer());
            if (resultTree != null) {
                //add the JTree to the result box
                resultPane.getViewport().add(resultTree);
                searchTime.setForeground(Color.BLACK);
                searchTime.setText("(" + searchtime.format(result.getSearchTime()) + ")");
            } else {
                resultPane.getViewport().setView(null);
                searchTime.setForeground(Color.red);
                searchTime.setText("No match found.");
            }
        } catch (NullPointerException ex) {
            ex.printStackTrace();
        }
}//GEN-LAST:event_searchButtonActionPerformed

    /**
     * Opening the XML file from the file menu
     *
     * @param evt
     */
    private void browseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_browseButtonActionPerformed
        openDialogForParseFile();
    }//GEN-LAST:event_browseButtonActionPerformed

    private void loadDB_ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadDB_ButtonActionPerformed
        // Create the dialog to select a FOLDER representing the loaded databases
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(Config.DB_FOLDER_STRING)); // root folders of loaded databases
        chooser.setDialogTitle("Select DB");
        chooser.setApproveButtonText("Select"); // Change "OK" button to "Select"
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); // Select only directories
        chooser.setAcceptAllFileFilterUsed(false); // disable the "All files" option.

        // Does the user select a folder (database)?
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            // Yes. Try to load it.
            DbAccess newDataset = controller.loadDataset(chooser.getSelectedFile().getName());
            
            if (newDataset != null) {
                //JTree tree = newDataset.getXmlTree();
                //JTree tree = new JTree();
                //tree.setCellRenderer(new PathTreeCellRenderer());
                //structureScrollPane.getViewport().add(tree);
                xmlFile_jTextField.setText(chooser.getSelectedFile().getName());
                populateStructuralSummary();
            } else {
                System.err.println("Fail to load DB");
            }
        }
    }//GEN-LAST:event_loadDB_ButtonActionPerformed

    private void datasetPanelFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_datasetPanelFocusGained
        // TODO add your handling code here:
        System.out.println("Focus gained parse");
    }//GEN-LAST:event_datasetPanelFocusGained

    private void jPanel6FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jPanel6FocusGained
        System.out.println("Focus gained load");
    }//GEN-LAST:event_jPanel6FocusGained

    private void chooseDataPaneStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_chooseDataPaneStateChanged

        int selectedIndex = chooseDataPane.getSelectedIndex();
        System.out.println("State changed " + selectedIndex);
    }//GEN-LAST:event_chooseDataPaneStateChanged

    private void datasetPanelComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_datasetPanelComponentShown
        System.out.println("Component shown ");
    }//GEN-LAST:event_datasetPanelComponentShown

    /**
     * Reads and displays the XML file
     *
     * @param fullPathFilename
     * @return
     * @throws java.io.IOException
     */
    private void openDialogForParseFile() {
        // Open a dialog for users to provide the file
        JFileChooser fc = new JFileChooser();
        FileFilter fileFilter = new FileNameExtensionFilter("JSON file", "json");
        fc.setFileFilter(fileFilter);
        fc.setAcceptAllFileFilterUsed(false); // disable the All Files option
        int returnVal = fc.showOpenDialog(null);
        // Did the users provide some file?
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // Yes. Get it.
            File file = fc.getSelectedFile();
            String fname = fc.getSelectedFile().getName();
            int index = fc.getSelectedFile().getName().lastIndexOf('.');
            String datasetName = fname.substring(0, index);

            if (fileFilter.accept(file)) {
                xmlFile_jTextField.setText(file.getAbsolutePath());

                // Does the directory exist?
                if (!controller.isDatasetCreated(datasetName)) {
                    // No. Start parsing
                    startParsing(datasetName, file);
                } else {
                    // Yes. It means the XML file has been stored in the database. Show a warning message.
                    String msg = "\"" + fname.concat("\" exist in Database. \nPlease load from Database.");
                    JOptionPane.showMessageDialog(this, msg, "Warning", JOptionPane.WARNING_MESSAGE);
                }
            } else {
                String msg = "Invalid file:\"" + fname + "\" \nPlease select a valid XML file";
                JOptionPane.showMessageDialog(this, msg, "Warning", JOptionPane.WARNING_MESSAGE);
            }
        }
    }

    private void startParsing(String datasetName, File file) {
        // Start parsing
        ParseDialog dialog = new ParseDialog(this, true);
        System.out.println("Start parsing " + datasetName);
        switch (configurePane.getSelectedIndex()) {
            case 0:
                int size = Integer.parseInt(this.staticTimestampSizeField.getText());
                // Set to 100 if too small
                if (size <= 0) {
                    size = 100;
                }
                controller.parseDataset(datasetName, file, dialog, new StaticIntervalGenerator(size), 0);
                break;
            case 1:
                int timelineSize = Integer.parseInt(this.timelineSize.getText());
                int maxIntervalSize = Integer.parseInt(this.maxIntervalSize.getText());
                // Set to 100 if too small
                if (timelineSize <= 0) {
                    size = 100;
                }
                if (maxIntervalSize <= 0) {
                    size = 100;
                }
                if (timelineSize < maxIntervalSize) {
                    timelineSize = maxIntervalSize;
                }
                controller.parseDataset(datasetName, file, dialog, new RandomIntervalGenerator(timelineSize, maxIntervalSize, true), 0);
                break;
            default:
                controller.parseDataset(datasetName, file, dialog, new ParsedTimetampIntervalGenerator(), 0);
                break;
        }
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
    }
    
    protected void populateStructuralSummary() {
        Database db = controller.getCurIndex().getDb();
        Set<String> pathNames = db.pathNameIndex.keySet();
        //System.out.println("DB got ");
        //JTree tree = db.getXmlTree();
        //JTree tree = new JTree();
        //System.out.println("Tree set ");
        //tree.setCellRenderer(new PathTreeCellRenderer());
        //structuredScrollPane.getViewport().add(tree);
            // you have list of words - wordList
        List<String> wordList= new ArrayList<String>(pathNames);
        Collections.sort(wordList);

        // create list model for JList
        DefaultListModel<String> model = new DefaultListModel<String>();
        // add all words from wordList to model
        for(String s : wordList){
           //System.out.println("adding " + s);
           // Remove '#' and the "#.root.
           if (s.length() > 6) model.addElement(s.substring(7));
        }

        // create JList with model - model
        JList<String> list = new JList<String>(model);

        // create scroll pane for scrolling JList
        structuredScrollPane.getViewport().add(list);
        //structuredScrollPane.getViewport().add(tree);
    }

    protected void finishParsing() {
        System.out.println("Finish parsing ");
        //Display Tree
        controller.resetIndexes();
        //System.out.println("Indexes reset ");

        populateStructuralSummary();
    }

    private boolean isIndexedUsed() {
        return true;
    }

    private boolean isAlgoManualSelected() {
        return false; //this.manualRadioButton.isSelected();
    }

    private DefaultTreeModel buildPathTreeModel(Collection<Path> paths) {
        // sort all path expressions
        SortedSet<String> sortedPathExprList = new TreeSet<String>();
        for (Path path : paths) {
            sortedPathExprList.add(path.getInfo().getPathExpr());
        }

        HashMap<String, DefaultMutableTreeNode> pathExprMap
                = new HashMap<String, DefaultMutableTreeNode>(); // pathExpr -> node
        ArrayList<DefaultMutableTreeNode> roots
                = new ArrayList<DefaultMutableTreeNode>();
        for (String pathExpr : sortedPathExprList) {
            int lastSplit = pathExpr.lastIndexOf('.');
            String parentPathExpr = pathExpr.substring(0, lastSplit);
            String label = pathExpr.substring(lastSplit + 1, pathExpr.length() - 1); // omit . and #
            DefaultMutableTreeNode node = new DefaultMutableTreeNode(label);
            DefaultMutableTreeNode parentNode = pathExprMap.get(parentPathExpr);
            if (parentNode != null) {
                parentNode.add(node);
                pathExprMap.put(pathExpr, node);
            } else {
                roots.add(node);
            }
        }

        DefaultTreeModel tree = null;
        if (roots.size() == 1) {
            tree = new DefaultTreeModel(roots.get(0));
        } else {
            DefaultMutableTreeNode tempRoot = new DefaultMutableTreeNode("root");
            for (DefaultMutableTreeNode root : roots) {
                tempRoot.add(root);
            }
            tree = new DefaultTreeModel(tempRoot);
        }
        return tree;
    }

    // <editor-fold defaultstate="collapsed" desc="class PathTreeCellRenderer">
    private class PathTreeCellRenderer extends DefaultTreeCellRenderer {

        private Font font, boldFont;

        public PathTreeCellRenderer() {
            // set up the look-&-feel of the rendered
            font = UIManager.getFont("Tree.font");
            if (font != null) {
                this.setFont(font);
                boldFont = font.deriveFont(Font.BOLD);
            }
        }

        /**
         * Sets the value of the current tree cell to value. If selected is
         * true, the cell will be drawn as if selected. If expanded is true the
         * node is currently expanded and if leaf is true the node represents a
         * leaf and if hasFocus is true the node currently has focus. tree is
         * the JTree the receiver is being configured for. Returns the Component
         * that the renderer uses to draw the value.
         *
         * @param tree
         * @param value
         * @param selected
         * @param expanded
         * @param leaf
         * @param row
         * @param hasFocus
         * @return
         */
        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value,
                boolean selected, boolean expanded, boolean leaf, int row,
                boolean hasFocus) {
            
            //return this;

            String stringValue = tree.convertValueToText(value, selected,
                    expanded, leaf, row, false);
            this.setText(stringValue);
            this.setEnabled(tree.isEnabled());




            if ((value != null) && (value instanceof DefaultMutableTreeNode)) {
                Object userObject = ((DefaultMutableTreeNode) value).getUserObject();
                if (userObject instanceof PathInfo) {
                    PathInfo pathInfo = (PathInfo) userObject;
                    if (pathInfo.isRepeatable()) {
                        this.setFont(boldFont);
                    } else {
                        this.setFont(font);
                    }
                    String pathExpr = pathInfo.getPathExpr();
                    int lastPeriod = pathExpr.lastIndexOf('.');
                    String text = pathExpr.substring(lastPeriod, pathExpr.length() - 1);
                    this.setText(text + " hello");
                    this.setEnabled(tree.isEnabled());
                }
            }
            return this;

        }
    }

//    /**
//    Add this override to recalculate the width of this JLabel.
//    The super class default behaviour miscalculates the width, and so the
//    '...'  can appear. Instead, we 'simulate' the FontMetrics'
//    stringWidth() method, by using charWidth(), plus some initialization
//    and padding
//     */
//    @Override
//    public Dimension getPreferredSize() {
//        Dimension dim = super.getPreferredSize();
//        FontMetrics fm = getFontMetrics(getFont());
//        char[] chars = getText().toCharArray();
//
//        int w = getIconTextGap() + 16;
//        for (char ch : chars) {
//            w += fm.charWidth(ch);
//        }
//        w += getText().length();
//        dim.width = w;
//        return dim;
//    }
    // </editor-fold>
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup algoButtonGroup;
    private javax.swing.JButton browseButton;
    private javax.swing.JTabbedPane chooseDataPane;
    private javax.swing.JTabbedPane configurePane;
    private javax.swing.JPanel datasetPanel;
    private javax.swing.JPanel fixedIntervalPanel;
    private javax.swing.ButtonGroup indexButtonGroup;
    private javax.swing.JPanel inputPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JButton loadDB_Button;
    private javax.swing.JTextField maxIntervalSize;
    private javax.swing.JPanel parseDataPane;
    private javax.swing.JPanel parseRepresentationPanel;
    private javax.swing.JPanel randomIntervalPanel;
    private javax.swing.JTextArea resultArea;
    private javax.swing.JScrollPane resultPane;
    private javax.swing.JTextField searchBox;
    private javax.swing.JButton searchButton;
    private javax.swing.JLabel searchTime;
    private javax.swing.JTextField staticTimestampSizeField;
    private javax.swing.JScrollPane structuredScrollPane;
    private javax.swing.JTextField timelineSize;
    private javax.swing.JTextField xmlFile_jTextField;
    // End of variables declaration//GEN-END:variables
}
